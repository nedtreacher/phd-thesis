# Python Code for Data Analysis {#sec-python}

## Code Repository

The code used for general analysis of field-effect transistor devices in this thesis was written with Python 3.8.8. Contributors to the code used include Erica Cassie, Erica Happe, Marissa Dierkes and Leo Browning. The code is located on GitHub and the research group OneDrive, and is available on request.

## Atomic Force Microscope Histogram Analysis {#sec-histogram-analysis}

The purpose of this code is to analyse atomic force microscope (AFM) images of carbon nanotube networks in .xyz format taken using an atomic force microscope and processed in Gwyddion (see @sec-afm-characterisation). It was originally designed by Erica Happe in Matlab, and adapted by Marissa Dierkes and myself for use in Python. 

$$
f(x) = k_1\exp{\Bigg(-\frac{{(x-m_1)}^{2}}{{2s_1}^{2}}\Bigg)} + k_2\exp{\Bigg(-\frac{{(x-m_2)}^{2}}{{2s_2}^{2}}\Bigg)} + ...
$${#eq-lin-combo-gaussian}

The .xyz data is initially sorted into bins with 0.15 nm size. The bin with the maximum number of counts is set at 0 nm, as this peak represents the mean of the surface roughness of the bare silicon. The parameters $m_i$, $s_i$, $k_i$ (i = 1, 2, 3) are used with objective function @eq-lin-combo-gaussian to overlay the data with normal distributions. These fitting parameters represent the mean (m), standard deviation (s) and amplitude (k) of each normal distribution. We can make approximations of some of these fitting parameters using the histogram data. 

$k_1$ is taken to be the maximum y-value of the data being fitted, $m_1$ is set to zero (used as a point of reference) and $s_1$ is taken as one-third of the difference between $m_1$ and the x-value of the first datapoint where the y-value is greater than 1% of $k_1$ (approximating one standard deviation). We find the distribution given by these values using @eq-lin-combo-gaussian, and subtract it from the existing dataset. 

Then, using the analysis technique outlined by Vobornik *et al.* [@Vobornik2023] in Gwyddion, we manually find estimates for the mean $m_2$ and standard deviation $s_2$ of the carbon nanotube bundle distribution. We then take $k_2$ to be the maximum y-value of this modified dataset, and $m_1$ to be the x-value of the maximum y-value. We then set $k_2$ so that the height of the resulting distribution at one standard deviation matches the height of the .xyz data histogram. We take this distribution, and subtract it from the existing dataset. 

The code also allows for discretely binning continuous data from fitted normal distributions and examining the proportion of counts above or below a particular height. 2.9 nm is roughly where 2 bundles with average size 1.45 nm can start to be present, and is used as an estimate of the boundary value between single-tube bundle diameters and multi-tube bundle diameters.

## Field-Effect Transistor Analysis {#sec-field-effect-transistor-analysis}

The purpose of this code is to analyse electrical measurements taken of field-effect transistor (FET) devices. Electrical measurements were either taken from the Keysight 4156C Semiconductor Parameter Analyser, National Instruments NI-PXIe or Keysight B1500A Semiconductor Device Analyser as discussed in @sec-electrical-characterisation; the code is able to analyse data taken from all three measurement setups. The main Python file in the code base consists of three related but independent modules: the first analyses and plots sensing data from the FET devices, the second analyses and plots transfer characteristics from channels across a device, and the third compares individual channel characteristics before and after a modification or after each of several modifications. The code base also features a separate config file and style sheet which govern the behaviour of the main code. The code base was designed collaboratively by myself and Erica Cassie over GitHub using the Sourcetree Git GUI.

The first of the three modules is for processing sensing datasets. This module imports sensing measurements in .csv format and analyses them, then outputs a plot of the raw data, alongside multiple plots which have been modified in various ways. It can also fit exponential and linear trendlines to regions of the sensing data, as well as find the signal change per analyte addition, and returns spreadsheets containing the results of these analyses. These spreadsheets include the standard deviation for all included parameters. Modified plots include normalised plots (type of normalisation can be set in config file), plots with fitted curves, plots with the linear baseline drift removed, plots of signal with analyte addition, "despiked" plots and "filtered" plots. It is possible to add annotations to any of these plots using the config file, and it is possible to produce a plot with a combination of these modifications.

The scipy.optimize.curve_fit module is used to fit linear and exponential curves to regions of interest of the sensing data. Initial parameters for the scipy.optimize.curve_fit module are chosen by approximating fitting parameters in a similar manner to the approach in @sec-histogram-analysis. For a linear fit $mt + b$, the parameters are simply set as $m=1$ and $b=0$. For an exponential fit $a\exp{(-t/\tau)} + c$, $c$ is set as the final current measurement of the region of interest and $a$ is set as the initial current measurement minus $c$. Then, $\tau$ is set as the time where current has dropped to $e^{-1}a + c$. 

"Despiked" plots have had spurious datapoints removed through the use of an interquartile range rolling filter. The window size of the rolling filter used was 40 datapoints, and datapoints in each window with a z-score above $\pm 3$ were removed from the plotted/processed data. "Filtered" plots had noise reduced using a moving median filter. The moving median filter is more effective at removing noise than a simple moving average, and has advantages over other filters (such as the Savitzky-Golay filter) when removing noise from data with sharp edges, as is the case for sensing data. Median filtering can also be used for baseline drift compensation, though this approach was not used in this thesis [@Stone2011]. The moving median filter used had a window of 40 datapoints. 

Plots of signal with analyte addition were constructed from current data after first removing baseline drift and applying a moving median filter. A simple difference calculation between the mean of the filtered current before an addition and the mean of the filtered current after the addition was performed at each addition. These differences were then normalised relative to the initial current. The signal with analyte addition give reasonably consistent results regardless of whether baseline drift was removed from the data, as shown in @fig-fig-spaa-plot-comparison. We can therefore be confident that robust signal with analyte addition plots are robust even in the presence of significant drift.

::: {#fig-spaa-plot-comparison layout="[50,50]"}

![](figures/app2/NTQ31C1_mean_simple_difference_before_and_after_step_filtered_concentrations.png){#fig-spaa-no-detrend}

![](figures/app2/NTQ31C1_mean_simple_difference_before_and_after_step_filtered_concentrations_detrend.png){#fig-spaa-detrend}

A comparison of signal with analyte addition plots taken from the same salt concentration sensing dataset (the same dataset as used in @fig-salt-conc-sensing). In (a), a simple difference calculation performed on filtered data was used, while in (b) the same calculation was performed on filtered data with the baseline drift removed, the method used in the body of the thesis. 
:::

The second module imports transfer measurements in .csv format and creates combined and individual plots of the eight channels on a single device. In combined plots, channels which are non-working, due to being shorted or non-conducting, are removed via setting a maximum and minimum possible on-current in the config file. Various parameters from the transfer characteristics are saved as a spreadsheet along with standard error. These parameters include on current, off current, subthreshold slope and threshold voltage for the carbon nanotube devices, and on current, off current and major Dirac point voltage for graphene devices. The device type being analysed can be set in the config file.

The third module imports several transfer measurements in .csv format and allows for comparison of the same channel before and after some modification. It also calculates the shift in either threshold voltage or major Dirac voltage of the device.