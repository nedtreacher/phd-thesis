# Python Code for Data Analysis {#sec-python}

## Code Repository

The code used for general analysis of field-effect transistor devices in this thesis was written with Python 3.8.8. Contributors to the code used include Erica Cassie, Erica Happe, Marissa Dierkes and Leo Browning. The code is located on GitHub and the research group OneDrive, and is available on request.

## Atomic Force Microscope Histogram Analysis {#sec-histogram-analysis}

The purpose of this code is to return morphology statistics such as height distribution and carbon nanotube coverage/density from atomic force microscope (AFM) images of carbon nanotube networks. The code uses the SciPy optimize package to fit two or three normal distributions to .xyz datasets from AFM images processed in Gwyddion (see @sec-afm-characterisation). The number of normal distributions was chosen based on which gave a better quality fit to the .xyz data. It was originally designed by Erica Happe in Matlab, and adapted by Marissa Dierkes and myself for use in Python. 

The .xyz data is initially sorted into bins with 0.15 nm size. The bin with the maximum number of counts is set at 0 nm, as this peak represents the mean of the surface roughness of the bare silicon. The fitting parameters $m_1$, $s_1$, $k_1$, $m_2$, $s_2$, $k_2$ (as well as $m_3$, $s_3$, $k_3$ for three normal distributions) are used in the objective function @eq-lin-combo-gaussian when optimising.

$$
f(x) = k_1\exp{\Bigg(-\frac{{(x-m_1)}^{2}}{{2s_1}^{2}}\Bigg)} + k_2\exp{\Bigg(-\frac{{(x-m_2)}^{2}}{{2s_2}^{2}}\Bigg)} + ...
$${#eq-lin-combo-gaussian}

These fitting parameters represent the mean (m), standard deviation (s) and amplitude (k) of each normal distribution. We can find the initial guess for these fitting parameters by using the histogram data to roughly approximate these values. $k_1$ is taken as the maximum y-value of the data being fitted, $m_1$ is set to zero and $s_1$ is taken as one-third of the difference between $m_1$ and the x-value of the first datapoint where the y-value is greater than 1% of $k_1$. We find the Gaussian given by these values, and subtract it from the existing dataset. We then take $k_2$ to be the maximum y-value of this modified dataset, and $m_1$ to be the x-value of the maximum y-value. $s_2$ is taken as the difference between $m_1$ and the x-value of the first datapoint where the y-value is greater than 60% of $k_2$. This process is repeated to find $k_3$ and $m_3$, and $s_3$ is one-third of the difference between $m_3$ and the x-value of the *last* datapoint where the y-value is greater than 1% of $k_3$. In this iterative manner, we find a reasonably good initial guess for our fit.

Using the objective function with these fitting parameters in the scipy.optimize.curve_fit module, we receive optimised fitting parameters which gave an R-squared value of 0.96 or greater. By calculating the area under each of the normal distributions found from the fit, we can find the proportion of the surface covered by carbon nanotube bundles. The code also allows for discretely binning continuous data from fitted normal distributions and examining the proportion of counts above or below a particular height.