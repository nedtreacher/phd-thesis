# Python Code for Data Analysis {#sec-python}

## Code Repository

The code used for general analysis of field-effect transistor devices in this thesis was written with Python 3.8.8. Contributors to the code used include Erica Cassie, Erica Happe, Marissa Dierkes and Leo Browning. The code is located on GitHub and the research group OneDrive, and is available on request.

## Atomic Force Microscope Histogram Analysis {#sec-histogram-analysis}

The purpose of this code is to analyse atomic force microscope (AFM) images of carbon nanotube networks in .xyz format taken using an atomic force microscope and processed in Gwyddion (see @sec-afm-characterisation). It was originally designed by Erica Happe in Matlab, and adapted by Marissa Dierkes and myself for use in Python. The code imports the .xyz data and sorts it into bins 0.15 nm in size for processing. To perform skew-normal distribution fits, both *scipy.optimize.curve_fit* and *scipy.stats.skewnorm* modules are used in this code.

## Raman Spectroscopy Analysis {#sec-raman-analysis}

The purpose of this code is to analyse a series of Raman spectra taken at different points on a single film (see @sec-raman-characterisation). Data is imported in a series of tab-delimited text files, with the low wavenumber spectrum (100 cm$^{-1} - 650$ cm$^{-1}$) and high wavenumber spectrum (1300 cm$^{-1} - 1650$ cm$^{-1}$) imported in separate datafiles for each scan location.

## Field-Effect Transistor Analysis {#sec-field-effect-transistor-analysis}

The purpose of this code is to analyse electrical measurements taken of field-effect transistor (FET) devices. Electrical measurements were either taken from the Keysight 4156C Semiconductor Parameter Analyser, National Instruments NI-PXIe or Keysight B1500A Semiconductor Device Analyser as discussed in @sec-electrical-characterisation; the code is able to analyse data taken from all three measurement setups. The main Python file in the code base consists of three related but independent modules: the first analyses and plots sensing data from the FET devices, the second analyses and plots transfer characteristics from channels across a device, and the third compares individual channel characteristics before and after a modification or after each of several modifications. The code base also features a separate config file and style sheet which govern the behaviour of the main code. The code base was designed collaboratively by myself and Erica Cassie over GitHub using the Sourcetree Git GUI.

The first of the three modules is for processing sensing datasets. This module imports sensing measurements in .csv format and analyses them, then outputs a plot of the raw data, alongside multiple plots which have been modified in various ways. It can also fit exponential and linear trendlines to regions of the sensing data, as well as find the signal change per analyte addition, and returns spreadsheets containing the results of these analyses. These spreadsheets include the standard deviation for all included parameters. Modified plots include normalised plots (type of normalisation can be set in config file), plots with fitted curves, plots with the linear baseline drift removed, plots of signal with analyte addition, "despiked" plots and "filtered" plots. It is possible to add annotations to any of these plots using the config file, and it is possible to produce a plot with a combination of these modifications.

The scipy.optimize.curve_fit module is used to fit linear and exponential curves to regions of interest of the sensing data. Initial parameters for the scipy.optimize.curve_fit module are chosen by approximating fitting parameters in a similar manner to the approach in @sec-histogram-analysis. For a linear fit $mt + b$, the parameters are simply set as $m=1$ and $b=0$. For an exponential fit $a\exp{(-t/\tau)} + c$, $c$ is set as the final current measurement of the region of interest and $a$ is set as the initial current measurement minus $c$. Then, $\tau$ is set as the time where current has dropped to $e^{-1}a + c$. 

"Despiked" plots have had spurious datapoints removed through the use of an interquartile range rolling filter. The window size of the rolling filter used was 40 datapoints, and datapoints in each window with a z-score above $\pm 3$ were removed from the plotted/processed data. "Filtered" plots had noise reduced using a moving median filter. The moving median filter is more effective at removing noise than a simple moving average, and has advantages over other filters (such as the Savitzky-Golay filter) when removing noise from data with sharp edges, as is the case for sensing data. Median filtering can also be used for baseline drift compensation, though this approach was not used in this thesis [@Stone2011]. The moving median filter used had a window of 40 datapoints. 

Plots of signal with analyte addition were constructed from current data after first removing baseline drift and applying a moving median filter. A simple difference calculation between the mean of the filtered current before an addition and the mean of the filtered current after the addition was performed at each addition. These differences were then normalised relative to the initial current. The signal with analyte addition give reasonably consistent results regardless of whether baseline drift was removed from the data, as shown in @fig-spaa-plot-comparison. We can therefore be confident that robust signal with analyte addition plots are robust even in the presence of significant drift.

::: {#fig-spaa-plot-comparison layout="[50,50]"}

![](figures/app2/NTQ31C1_mean_simple_difference_before_and_after_step_filtered_concentrations.png){#fig-spaa-no-detrend}

![](figures/app2/NTQ31C1_mean_simple_difference_before_and_after_step_filtered_concentrations_detrend.png){#fig-spaa-detrend}

A comparison of signal with analyte addition plots taken from the same salt concentration sensing dataset (the same dataset as used in @fig-salt-conc-sensing). In (a), a simple difference calculation performed on filtered data was used, while in (b) the same calculation was performed on filtered data with the baseline drift removed, the method used in the body of the thesis. 
:::

The second module imports transfer measurements in .csv format and creates combined and individual plots of the eight channels on a single device. In combined plots, channels which are non-working, due to being shorted or non-conducting, are removed via setting a maximum and minimum possible on-current in the config file. Various parameters from the transfer characteristics are saved as a spreadsheet along with standard error. These parameters include on current, off current, subthreshold slope and threshold voltage for the carbon nanotube devices, and on current, off current and major Dirac point voltage for graphene devices. The device type being analysed can be set in the config file.

The third module imports several transfer measurements in .csv format and allows for comparison of the same channel before and after some modification. It also calculates the shift in either threshold voltage or major Dirac voltage of the device.